var ConvolutedCubeMap = require('./ConvolutedCubeMap');
var upgradeFragmentShaderToHaveFakeHDRIOutput = require('./upgradeFragmentShaderToHaveFakeHDRIOutput');
//awesome shim to empower native materials with fake 8bit hdri hack for mobile
var materialsToUpgrage = [
	'basic',
	'phong'
];
materialsToUpgrage.forEach(function(mat) {
	var shader = THREE.ShaderLib[mat];
	shader.fragmentShader = upgradeFragmentShaderToHaveFakeHDRIOutput(shader.fragmentShader);
});

console.warn('warning: THREEjs has been shimmed with extra shader routines to provide HDRI emulation via the alpha channel. This may break certain expected behaviours.');

//end shim

function LightProbe(near, far, resolution, type) {
	near = near || .01;
	far = far || 1000;
	resolution = resolution || 128;
	this.bufferType = type;
	var format;
	if(type === ConvolutedCubeMap.FakeHDRI || type === ConvolutedCubeMap.FakeHDRIThrough) {
		type = THREE.UnsignedByteType;
		format = THREE.RGBAFormat;
	}
	THREE.CubeCamera.call(this, near, far, resolution, type, format);

	if(this.renderTarget.type !== this.bufferType) console.log("LightProbe: WARNING: This version of three.js does not support Float Type CubeCamera. This is OK, but if you use a patched version of threejs, cubemaps can be HDRI!");

	this.convolutedCubeMaps = [];
}

LightProbe.prototype = Object.create(THREE.CubeCamera.prototype);

LightProbe.prototype.update = function(renderer, scene, updateAllconvolutionCubeMaps) {
	this.updateCubeMap(renderer, scene);
	if(updateAllconvolutionCubeMaps !== false) {
		for (var i = this.convolutedCubeMaps.length - 1; i >= 0; i--) {
			this.convolutedCubeMaps[i].update(renderer);
		};
	}
}

LightProbe.prototype.updateManual = function(renderer, renderTarget, updateAllconvolutionCubeMaps) {
	this.renderTarget = renderTarget;
	if(updateAllconvolutionCubeMaps !== false) {
		for (var i = this.convolutedCubeMaps.length - 1; i >= 0; i--) {
			this.convolutedCubeMaps[i].sourceCubMap = renderTarget;
			this.convolutedCubeMaps[i].update(renderer);
		};
	}
}

LightProbe.prototype.getCubeMapGenerator = function(resolution, blurStrength, brightness, iterations, flipX, prerenderCallback, postrenderCallback) {
	var convolutedCubeMap = new ConvolutedCubeMap(this.renderTarget, resolution, blurStrength, brightness, iterations, flipX, this.bufferType, prerenderCallback, postrenderCallback);
	this.convolutedCubeMaps.push(convolutedCubeMap);
	return convolutedCubeMap;
}

LightProbe.FakeHDRI = ConvolutedCubeMap.FakeHDRI;
LightProbe.FakeHDRIThrough = ConvolutedCubeMap.FakeHDRIThrough;

module.exports = LightProbe;